# Варианты директив Referrer Policy

## HTTP referer

**Заголовок запроса Referer содержит URL исходной страницы, с которой был осуществлён переход н
а текущую страницу**. Заголовок Referer позволяет серверу узнать откуда был осуществлён переход 
на запрашиваемую страницу. Сервер может анализировать эти данные, записывать их в логи 
или оптимизировать процесс кеширования.

**Referer** содержит сведения о ссылающейся странице (так называемый «реферер»)

> Предупреждение: Заголовок Referer может раскрыть информацию пользователя об истории посещённых страниц,
> что может привести к нарушению приватности.

`Referer` (от ошибочного написания англ. referrer — отсылающий, направляющий) — в протоколе HTTP — один 
из заголовков запроса клиента. Содержит URL источника запроса. Если перейти с одной страницы на другую, 
**referer будет содержать адрес первой страницы**. Часто на HTTP-сервере устанавливается программное обеспечение, 
анализирующее referer и извлекающее из него различную информацию. Так, например, владелец веб-сайта получает 
возможность узнать, по каким поисковым запросам, как часто и на какие именно страницы попадают люди. 
Если HTTP-клиент загружает с сервера картинку, представленную на какой-либо странице, то referer будет 
содержать адрес этой страницы. Некоторые HTTP-серверы перед выдачей картинки анализируют referer и не показывают 
картинку, если запрос приходит с другого сайта (а, например, показывают маленькое изображение-заглушку). 


## Origin (источник / исход)

Заголовок запроса `Origin` показывает откуда будет производиться загрузка. Он не включает в себя какую-либо 
информацию о пути, содержит в себе лишь имя сервера (протокол, имя хоста, номер порта. Заголовок отправляется 
как с CORS, так и с POST запросами. Он похож на заголовок `Referer`, но, в отличие от этого заголовка, 
не раскрывает весь путь.

Протокол (включая ://), доменное имя (или IP-адрес) и номер порта (включая знак двоеточия (:) URL-адреса. 


**Синтаксис**
```
Origin: ""
Origin: <протокол> "://" <имя_хоста> [ ":" <порт> ]
```

## Что такое Origin (источник), Path (путь) и Query String (строка запроса)

Исходя из предоставленной информации, давайте разберем ключевые понятия:

### Origin (источник)

Исход - это базовая часть URL, включающая схему протокола, доменное имя и порт. Например, 
для URL https://www.example.com:8080/path/to/page исход будет https://www.example.com:8080.

### Путь (Path)

Путь - это часть URL, которая следует после имени хоста и перед именем файла. Он определяет структуру каталогов 
на сервере, где находится запрашиваемый ресурс. Например, в URL https://www.example.com/path/to/page путь будет /path/to/.

### Строка запроса (Query String)

Строка запроса - это часть URL после символа вопроса (?), которая содержит параметры и их значения. Она используется 
для передачи дополнительной информации от клиента к серверу. Например, 
в URL https://www.example.com/search?q=web+development строка запроса будет q=web+development.

### Примеры использования:

1. Полный URL: https://www.example.com/path/to/page?param=value
   - Исход: https://www.example.com
   - Путь: /path/to/
   - Строка запроса: ?param=value

2. Кросс-оригинальный запрос:
   https://api.another-site.com/data?user_id=123
   - Исход: https://api.another-site.com
   - Путь: /data
   - Строка запроса: ?user_id=123

3. Запрос с одного источника:
https://www.example.com/script.js?v=1.0
   - Исход: https://www.example.com
   - Путь: /script.js
   - Строка запроса: ?v=1.0

Эти компоненты часто используются при настройке политик реферера и определении, какая информация должна быть 
отправлена вместе с HTTP-запросом.

Citations:
[1](https://habr.com/ru/companies/avito/articles/710660/)
[2](https://mhost.by/blog/article/11/http-zaprosy-metody-i-protokol-peredachi-giperteksta)
[3](https://evmservice.ru/blog/metody-get-i-post/)
[4](https://www.adogy.com/ru/terms/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B0-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0/)
[5](https://ru.wikipedia.org/wiki/HTTP)
[6](https://worksolutions.ru/blog/zaprosy-parsing-hranenie-vse-chto-nuzhno-znat-o-rabote-s-dannymi-vo-frontend-prilozhenii/)
[7](https://www.cleverence.ru/articles/elektronnaya-kommertsiya/rest-api-chto-eto-takoe-prostymi-slovami-primery-zaprosov-varianty-ispolzovaniya-servisa-metody/)
[8](https://iit-web-lectures.readthedocs.io/ru/latest/www/http.html)
[9](https://www.securitylab.ru/analytics/489752.php?R=1)
[10](https://infostart.ru/1c/articles/516810/)


## Существует несколько уровней ограничения для отправки информации о реферере. Вот основные из них:

### 1. no-referrer

Это самый строгий уровень ограничения. Браузер не отправляет никакую информацию о реферере.
Самый убийственный вариант, когда сведения о ссылающейся странице (так называемый «реферер») к получателю 
трафика вообще не передаются. Даже если получатель трафика - этот же самый сайт (переход по внутренней ссылке 
в пределах сайта).

### 2. no-referrer-when-downgrade

Отправляется только Origin (источник), путь и строка запроса, если протокол безопасности остается тем же или улучшается 
(например, HTTP -> HTTPS). Для менее защищенных целей (HTTPS -> HTTP) не отправляется референс.

Реферер не передаётся от https к http сайту, и передаётся во всех остальных случаях. Причём это справедливо и для варианта 
общения сайта с самим собой, но в разных протоколах. С большой степенью вероятности отсутствие данного МЕТА-тега 
вообще приведёт к такому же эффекту.

### 3. origin

Отправляется только Origin (источник - доменное имя). На какой бы сайт не ссылалась страница с таким тегом, в качестве реферера будет 
виден лишь домен сайта. Документ в URL-е не передаётся. Протокол принимающего трафик сайта безразличен.  Метрики откажутся 
работать - внутренние переходы не отследить.

### 4. origin-when-cross-origin

Когда выполняется запрос с того же протокола (например, HTTP -> HTTP), отправляется Origin (источник), путь и строка запроса. 
Для кросс-оригинальных запросов отправляется только Origin.

### 5. same-origin

Отправляется только Origin (источник) для кросс-оригинальных запросов. Для запросов с одного источника отправляется полный URL.
Очень интересный вариант, когда реферер передаётся только внутри собственного сайта, при переходе между его документами. 
Но только в случае, когда этот сайт работает по https протоколу. В любом другом случае реферера просто нет.

Данный вариант предназначен для накопления статистики перемещения между внутренними документами сайта посредством 
какой-либо метрики, но при этом сайт ничего не сообщает об URL-ах своих документов прилинкованным оттуда внешним сайтам.

### 6. strict-origin

Отправляется только Origin (источник), если протокол безопасности остается тем же (например, HTTPS -> HTTPS). 
Для менее защищенных целей (HTTPS -> HTTP) не отправляется реферер.

То же самое, что и same-origin, но уже играет роль иерархия протоколов. При переходе с https сайта 
на http (в том числе и в пределах одного домена) реферер не передаётся. 
Во всех остальных случаях в качестве реферера фигурирует морда сайта\*, а не его конкретный документ.

\* Сленговый термин, обозначающий главную страницу веб-сайта как его «лицо». Синонимом является термин «хомяк», образованное 
в результате игры слов «home page» — домашняя страница. «Морда» сайта имеет важную роль в комплексном продвижении сайта.

### 7. strict-origin-when-cross-origin

Этот уровень является рекомендуемым по умолчанию для большинства современных браузеров. Отправляется полный URL для запросов 
с одного источника. Для кросс-оригинальных запросов отправляется только Origin (источник), если протокол безопасности 
остается тем же. Для менее защищенных целей не отправляется реферер.

Более строгий вариант - то же, что и origin-when-cross-origin, но если ссылающийся сайт в https протоколе, 
а прилинкованный в http, то реферер вообще пропадает.

### 8. unsafe-url

Отправляется полный URL для любых запросов, независимо от уровня безопасности. 
Реферер передаётся в любом случае.

### Рекомендации.

Как видим, МЕТА-тег «Referrer Policy» хоть и не отличается разнообразием вариантов (их номенклатуру можно было бы и расширить), 
тем не менее позволяет работать с реферерами по-разному, в зависимости от протокола сайта. Это ценное свойство, 
особенно если можно открыть сайт хоть «безопасно», хоть «не безопасно».

Более полезна способность тега ограничить передачу реферера либо совсем, либо только внешним сайтам. Этим следует 
обязательно пользоваться на страницах, требующих секьюритетности - всякие там личные кабинеты, тикеты, и тому подобное.

Правда, если сервисы написаны по уму (например, URL всех страниц сервиса одинаковый, ибо данные передаются исключительно 
через POST, а GET параметры не используются вообще), тегу особо и нечего защищать. Разве что сам факт наличия исходящей ссылки.

Тем не менее, тег однозначно полезный, знать про него надо.

Каждый из этих уровней предоставляет разные уровни защиты приватности и функциональности. 
Выбор зависит от конкретных требований безопасности и функциональности вашего сайта.

Citations:
[1](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy)
[2](https://web.dev/articles/referrer-best-practices)
[3](https://www.w3.org/TR/referrer-policy/)
[4](https://developer.mozilla.org/en-US/docs/Web/Security/Practical_implementation_guides/Referrer_policy)
[5](https://probely.com/vulnerabilities/insecure-referrer-policy/)
[6](https://http.dev/referrer-policy)
[7](https://www.malcare.com/blog/referrer-policy-wordpress/)
[8](https://www.vpnunlimited.com/help/cybersecurity/referrer-policy?srsltid=AfmBOorz_B9Fr5jTbsjH-9v_4SxCFCkl7cs5RPwq_MIuGpJNGuVfxSRY)
[9](https://www.softforge.co.uk/blogs/all-topics/the-referrer-policy-security-header-history-purpose-and-implementation)
[10](https://sigmaos.com/tips/glossary/browser-terms-explained-referrer-policy)


## Как я могу проверить текущие настройки политики рефералов?

Использование инструментов разработчика

1. Откройте инструменты разработчика вашего браузера (обычно F12 или Ctrl+Shift+I).

2. Перейдите на вкладку «Сеть».

3. Перезагрузите страницу.

4. Найдите запрос на текущей странице и нажмите на него.

5. Найдите заголовок «Политика реферера» в разделе «Заголовки».

### Использование JavaScript

Вы можете использовать следующую команду JavaScript в консоли:
```js
document.referrerPolicy
```
Это вернет текущую политику реферера в виде строки. 

### Проверка определенных элементов

Для отдельных элементов, таких как ссылки или изображения, вы можете проверить их и найти r`eferrerpolicy` атрибут.
Использование онлайн-инструментов

1. Посетите Securityheaders.com и введите URL-адрес сайта, который вы хотите проверить.

2. Он проанализирует заголовки сайта и отобразит политику реферера вместе с другими заголовками безопасности.

### Ключевые моменты:

- Разные браузеры могут отображать политику реферера в своих инструментах разработчика немного по-разному.
- Некоторые старые браузеры могут не отображать политику реферера явно.
- Политика по умолчанию варьируется в зависимости от браузера, при этом большинство современных браузеров используют
`strict-origin-when-cross-origin`.

### Лучшие практики:

- Регулярно просматривайте и обновляйте свою политику рефералов с учетом ваших потребностей в безопасности.
- Рассмотрите возможность использования `strict-origin-when-cross-origin` как хороший баланс между безопасностью и функциональностью.
- Имейте в виду, что изменение политики рефералов может повлиять на взаимодействие сторонних служб с вашим сайтом.

Помните, что точный метод проверки политики реферера может незначительно отличаться в зависимости от версии вашего браузера и операционной системы. 

[phind](https://www.phind.com/search?cache=h71zdc81r8b4ojlgew8nots3)



## no-referrer

Не передает никакой информации о реферере. Это наиболее строгий режим, обеспечивающий максимальную конфиденциальность. 
Для изменения политики "no-referrer" в браузере существует несколько способов:

### Через настройки браузера

1. Откройте настройки вашего браузера (например, Chrome).

2. Найдите раздел, связанный с безопасностью или конфиденциальностью.

3. Поищите опцию "Политика реферера" или "Настройка реферера".

4. Измените значение на "no-referrer" или выберите соответствующий вариант.

### Через командную строку

Для Chrome можно использовать команду:

```
chrome.exe --disable-features=IsolateOriginsSameSiteCookies --disable-features=IsolateOriginsSameSiteCredentials
```

### Через мета-тег в HTML

На веб-странице можно добавить мета-тег:

```html
<meta name="referrer" content="no-referrer">
```

### Через JavaScript

Можно установить политику программно:

```javascript
document.referrerPolicy = 'no-referrer';
```

### Ключевые моменты:

- Политика "no-referrer" обеспечивает максимальную конфиденциальность, но может нарушить работу некоторых сайтов.
- Изменение этой политики может повлиять на функциональность определенных веб-приложений.
- Рекомендуется тестировать изменения в безопасной среде перед применением их в производственной среде.

### Заключение:

Изменение политики "no-referrer" может значительно повлиять на работу веб-сайтов и безопасности пользовательских данных. Убедитесь, что вы понимаете последствия такого изменения перед его применением.

[phind](https://www.phind.com/search?cache=h71zdc81r8b4ojlgew8nots3)

