# Структура URL

## Схема или протокол (Scheme & Protocol)

![Иллюстрация к проекту](/img/mdn-url-protocol@x2.png)

****

## Постоянные ссылки - Permalink

**Permalink** или **permanent link** (постоянная ссылка) — это URL-адрес, который должен оставаться неизменным в течение многих лет в будущем, 
создавая гиперссылку , менее подверженную разрушению ссылок . Постоянные ссылки часто отображаются просто, 
то есть как чистые URL-адреса , чтобы их было легче набирать и запоминать.


### Permalink detection (Обнаружение постоянных ссылок)
```html
<link rel="bookmark" href="http://example.com/bookmark/123/" />
```
**Permalinks** могут быть **указаны в HTML-коде страницы**, чтобы средства автоматического просмотра могли обнаружить 
постоянную ссылку и использовать ее для создания ссылок вместо указанного URL-адреса . 



### Виды URL:
- **Статический URL** - представляет собой простой адрес страницы или файла в Интернете и остаётся неизменным, то есть не зависит
от каких-либо параметров или данных. Их легко читать и запоминать, они удобны для ссылок на конкретные страницы или файлы на сайте.
- **Человекопонятный URL (ЧПУ)** – это подход к созданию URL, который делает его более читабельным для людей. Вместо использования
ID номеров или других параметров в адресной строке, ЧПУ использует слова или фразы, которые отражают содержание страницы или
ее местоположение на сайте.
- **Динамический URL** - формируется на основе параметров или данных, передаваемых через адресную строку. Обычно его используют
для генерации страниц с динамическим содержимым на основе запросов пользователя или других переменных. Динамические URL могут
содержать символы вопроса и амперсанда, которые указывают на параметры, их значения.

## История URL

**URL** (Uniform Resource Locator) — это веб-адрес, который используется для поиска и доступа к сайтам, каждой их страничке.

URL-адрес был создан в 1990 году, изначально как внутреннее решение, применяемое исключительно в CERN и использовали для обмена 
данными **Enquire** внутри компании.

**ENQUIRE** — система обмена документами, которую **Тим Бернерс-Ли** разработал для CERN в 1980. Многие идеи, использованные в **Enquire**, 
спустя 9 лет нашли своё применение в Web (всемирной паутине) и её усовершенствованной реализации **семантической паутине Semantic Web** 
(**Web 3.0** - не путать с Web3).


## Web 3.0 vs Web3

Web3 — это идея новой версии Всемирной паутины, которая включает в себя такие **концепции, как децентрализация, технологии блокчейна 
и экономику, основанную на токенах**. Это отличается от Тима Бернерса-Ли концепции семантической сети . Некоторые технологи 
и журналисты противопоставляют его Web 2.0 , в котором, по их словам, данные и контент централизованы в небольшой группе компаний, 
которую иногда называют «Технологическими гигантами». Термин «Web3» был придуман **в 2014 году Ethereum** соучредителем Гэвином Вудом, 
а в 2021 году эта идея вызвала интерес со стороны криптовалютных энтузиастов, крупных технологических компаний и фирм венчурного 
капитала. Концепции Web3 впервые были представлены в 2013 году.

**Web3** отличается от Тима Бернерса-Ли 1999 года концепции семантической сети, которую также иногда называют **Web 3.0**. В то время 
как семантическая сеть представляла собой сеть связанных данных, **Web3 в контексте блокчейна относится к децентрализованному Интернету**, построенному на **технологиях распределенного реестра**.

Скептетиз по поводу Web3. В начале 2022 года Мокси Марлинспайк, создатель Signal, сформулировал, что Web3 не так децентрализован, 
как кажется, в основном из-за консолидации в сфере криптовалют, в том числе в интерфейсах программирования приложений блокчейна, 
которые в настоящее время в основном контролируются компаниями Alchemy и Infura; криптовалютные биржи, на которых в основном доминируют 
Binance, Coinbase, MetaMask и OpenSea; и рынок стейблкоинов, на котором в настоящее время доминирует Tether. Марлинспайк также з
аметил, что новая паутина похожа на старую.

**Web 1.0** и **Web 2.0** относятся к эпохам в истории Всемирной паутины , развивавшейся с помощью различных технологий и форматов. 
**Веб 1.0 относится примерно к периоду с 1989 по 2004 год**, когда большинство сайтов состояло из статических страниц , 
а подавляющее большинство пользователей были потребителями, а не производителями контента. Веб 2.0 основан на идее 
«Интернет как платформа» и сосредоточен на созданном пользователями контенте, загруженном на форумы , в социальные сети 
и сетевые службы, блоги и вики , а также в другие сервисы. Обычно считается, что появление Web 2.0 началось примерно в 2004 году 
и продолжается по сей день.

**Web 3.0** известная как Semantic Web - Семантическая сеть (**не путать с Web3**), является расширением Всемирной паутины 
посредством стандартов установлен Консорциумом Всемирной паутины (W3C). Цель семантической сети — сделать Интернета данные 
машиночитаемыми. 

Семантический HTML относится к традиционной практике HTML, заключающейся в разметке в соответствии с намерением, 
а не непосредственном указании деталей макета. Например, использование &lg;em&tg; обозначающий «акцент», а не &lg;i&tg, 
который определяет курсив. Детали макета оставляются на усмотрение браузера в сочетании с каскадными таблицами стилей. 
Но эта практика не позволяет определить семантику таких объектов, как предметы для продажи или цены.

Микроформаты расширяют синтаксис HTML для создания машиночитаемой семантической разметки объектов, включая людей, 
организации, события и продукты. Подобные инициативы включают RDF , Microdata и Schema.org. 

Веб 4.0 - следующее поколение Интернета. По некоторым данным, это Сеть, в которой задействован искусственный интеллект. Интернет вещей , повсеместные вычисления, повсеместные вычисления и Сеть вещей среди других концепций.


## Структура URL для FTP

**Протокол** - означает способ подключения к тому или иному ресурсу. В зависимости от необходимости использования это может быть 
защищенный TLS — HTTPS, привычный HTTP, протокол передачи различных файлов FTP и прочие способы соединения с хостом.

<img src="https://github.com/newstas/WordPress/blob/51439866bb6895039a7f1f0b6094993a7b78de55/img/URLshema.png" width="960">

**Логин и пароль** - комбинация этой пары при необходимости передает авторизационные данные, применяемые для некоторых протоколов. 
Один из примеров — FTP.

**Хост** - чаще всего это IP-адрес конечного сервера. Благодаря использованию DNS в последнее время надобность писать цифровое 
обозначение значительно снизилась. Это существенно упростило систему. Указывается только буквенный адрес сайта с обозначением его зоны домена.

**Порт** - используется для подключения ресурса к серверу. Для каждого существует заранее определенное значение системы. Например, 
для HTML применяется порт 80.

**Путь** - для доступа к нужному файлу он формируется согласно образцу, находящемуся в системе файлов в компьютере. Через слеш (/) идет 
перечисление в порядке возрастания (иерархии) папки, а описание завершается названием и расширением файла.

**Параметры** - передаются на управляющие скрипты сервера. Если это HTML, то возможно читать отправленные параметры в качестве 
данных метода GET.

**Якорь** - опциональная строка для протоколов HTTP/HTTPS. Якорь применяется для обозначения области на странице. Помимо этого, 
он необходим и для работы некоторых JavaScript. 

## Punycode для доменов .РФ

Punycode ([ˈpjuːniˌkəʊd]) — стандартизированный **метод преобразования** последовательностей **Unicode-символов** в так называемые 
**ACE-последовательности** (англ. ASCII-compatible encoding — кодировка, совместимая с **ASCII**), которые состоят только 
из алфавитно-цифровых символов, как это разрешено в доменных именах. 

При копировании адреса из строки браузера кириллические домены трансформируются в специальную кодировку Punycode для 
соответствия утвержденной системе доменных имен. Так, например, адрес `сайт.рф` в этой кодировке будет выглядеть 
как `http://xn--80aswg.xn--p1ai`. 

Важнейшей причиной введения Punycode был тот факт, что в утверждённой стандартом системе доменных имен разрешены 
**только 26 символов латинского алфавита, цифры от 0 до 9 и дефис** — всего 37 символов. Для английского и некоторых других 
языков на основе латинского алфавита этого достаточно, однако другие языки могут содержать дополнительные символы. 
Чтобы обойти это ограничение и обеспечить совместимость с уже существующим ПО, был разработан Punycode

Алгоритм преобразования состоит из двух этапов. На первом этапе из исходного текста выбираются все символы, входящие 
в основную кодировку ASCII (коды 0—127), и переносятся подряд в закодированное слово и добавляется дефис. После этого, 
если в тексте встретились не ASCII-символы, к закодированному слову добавляются символы, преобразование которых идёт 
по процедуре, описанной в RFC 3492.

****


## Краткий справочник по заголовкам безопасности

### Заголовки безопасности, рекомендуемые для веб-сайтов, которые обрабатывают конфиденциальные данные пользователей:

[Политика безопасности контента (CSP)](#csp)

[Доверенные типы](#tt)

### Заголовки безопасности, рекомендуемые для всех веб-сайтов:

[Параметры X-Content-Type](#xcto)

[Параметры X-Frame](#xfo)

[Политика ресурсов перекрестного происхождения (CORP)](#corp)

[Политика открытия перекрестного происхождения (COOP)](#coop)

[Строгая транспортная безопасность HTTP (HSTS)](#hsts)

### Заголовки безопасности для веб-сайтов с расширенными возможностями:

[Совместное использование ресурсов между источниками (CORS)](#cors)

[Политика внедрения перекрестного происхождения (COEP)](#coep)

Известные угрозы в Интернете

Прежде чем углубляться в заголовки безопасности, узнайте об известных угрозах в Интернете и о том, почему вы хотите использовать эти заголовки безопасности.



#### Политика безопасности контента - Content Security Policy (CSP) (CSP)

[Межсайтовый скриптинг (XSS)](https://www.google.com/about/appsecurity/learning/xss/?hl=ru) — это атака, при которой уязвимость на веб-сайте позволяет внедрить и выполнить вредоносный скрипт.

`Content-Security-Policy` предоставляет дополнительный уровень для смягчения XSS-атак, ограничивая сценарии, которые могут выполняться на странице.

Рекомендуется включить строгий CSP, используя один из следующих подходов:

*   Если вы отображаете свои HTML-страницы на сервере, используйте **строгий CSP на основе nonce** .
*   Если ваш HTML-код должен обслуживаться статически или кэшироваться, например, если это одностраничное приложение, используйте **строгий CSP на основе хэша** .

Пример использования: CSP на основе nonce.

    Content-Security-Policy:
      script-src 'nonce-{RANDOM1}' 'strict-dynamic' https: 'unsafe-inline';
      object-src 'none';
      base-uri 'none';


Как использовать CSP

### Рекомендуемое использование

**Примечание.** CSP может служить _дополнительной_ защитой от XSS-атак; вам все равно следует избегать (и очищать) пользовательский ввод.

#### 1\. Используйте строгий CSP на основе nonce {: #nonce-based-csp}

Если вы отображаете свои HTML-страницы на сервере, используйте **строгий CSP на основе nonce** .

**Внимание:** Nonce — это случайное число, используемое только один раз. CSP на основе nonce безопасен только в том случае, если вы можете генерировать разные nonce для каждого ответа. Если вы не можете этого сделать, используйте вместо этого [CSP на основе хэша](#step_1_decide_if_you_need_a_nonce-_or_hash-based_csp) .

Сгенерируйте новое значение nonce скрипта для каждого запроса на стороне сервера и установите следующий заголовок:

файл конфигурации сервера

Content\-Security\-Policy:  script\-src 'nonce-{RANDOM1}' 'strict-dynamic' https: 'unsafe-inline';  object\-src 'none';  base\-uri 'none';  

В HTML, чтобы загрузить скрипты, установите для атрибута `nonce` всех тегов `<script>` одну и ту же строку `{RANDOM1}` .

index.html

<script nonce\="{RANDOM1}" src\="https://example.com/script1.js"\></script>  
<script nonce\="{RANDOM1}"\>  // Inline scripts can be used with the <code>nonce</code> attribute.  
</script>  

[Google Photos](https://photos.google.com/?hl=ru) — хороший пример строгого CSP на основе nonce. Используйте DevTools, чтобы увидеть, как он используется.

#### 2\. Используйте строгий CSP на основе хэша {: #hash-based-csp}

Если ваш HTML-код должен обрабатываться статически или кэшироваться, например, если вы создаете одностраничное приложение, используйте **строгий CSP на основе хэша** .

файл конфигурации сервера

Content\-Security\-Policy:  script\-src 'sha256-{HASH1}' 'sha256-{HASH2}' 'strict-dynamic' https: 'unsafe-inline';  object\-src 'none';  base\-uri 'none';  

В HTML вам потребуется встроить свои скрипты, чтобы применить политику на основе хеширования, поскольку [большинство браузеров не поддерживают хеширование внешних скриптов](https://wpt.fyi/results/content-security-policy/script-src/script-src-sri_hash.sub.html?label=master&label=experimental&aligned) .

index.html

<script>  
...// your script1, inlined  
</script>  
<script>  
...// your script2, inlined  
</script>  

Чтобы загрузить внешние сценарии, прочтите раздел «Динамическая загрузка исходных сценариев» в разделе [«Вариант Б: заголовок ответа CSP на основе хеша»](https://web.dev/articles/strict-csp?hl=ru#step_1_decide_if_you_need_a_nonce-_or_hash-based_csp) .

[CSP Evaluator](https://csp-evaluator.withgoogle.com/) — хороший инструмент для оценки вашего CSP, но в то же время хороший пример строгого CSP на основе nonce. Используйте DevTools, чтобы увидеть, как он используется.

### Поддерживаемые браузеры

\* `https:` является запасным вариантом для Safari, а `unsafe-inline` — запасным вариантом для очень старых версий браузера. `https:` и `unsafe-inline` не делают вашу политику менее безопасной, поскольку они будут игнорироваться браузерами, поддерживающими `strict-dynamic` . Подробнее читайте в разделе [«Добавление резервных вариантов для поддержки Safari и более старых браузеров»](https://web.dev/articles/strict-csp?hl=ru#step_4_optional_add_fallbacks_to_support_old_browser_versions) . \* Safari пока _не_ поддерживает `strict-dynamic` . Но строгий CSP, как в приведенных выше примерах, безопаснее, чем CSP из белого списка (и гораздо безопаснее, чем вообще отсутствие CSP) для всех ваших пользователей. Даже в Safari строгий CSP защищает ваш сайт от некоторых типов XSS-атак, поскольку наличие CSP запрещает определенные небезопасные шаблоны.

### Что еще следует отметить о CSP

*   Директива [`frame-ancestors`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors) защищает ваш сайт от кликджекинга — риска, который возникает, если вы разрешаете ненадежным сайтам встраивать ваш сайт. Если вы предпочитаете более простое решение, вы можете использовать [`X-Frame-Options`](##xfo) для блокировки загрузки, но `frame-ancestors` предоставляют вам расширенную конфигурацию, позволяющую использовать только определенные источники в качестве средств внедрения.
*   Возможно, вы использовали [CSP, чтобы гарантировать, что все ресурсы вашего сайта загружаются через HTTPS](https://web.dev/articles/fixing-mixed-content?hl=ru#content_security_policy) . Это стало менее актуальным: в настоящее время большинство браузеров блокируют [смешанный контент](https://web.dev/articles/what-is-mixed-content?hl=ru) .
*   Вы также можете установить CSP в [режиме только отчетов](https://web.dev/articles/strict-csp?hl=ru#step_2_set_a_strict_csp_and_prepare_your_scripts) .
*   Если вы не можете установить CSP в качестве заголовка на стороне сервера, вы также можете установить его как метатег. Обратите внимание, что вы не можете использовать режим **«только отчет»** для метатегов (хотя [это может измениться](https://github.com/w3c/webappsec-csp/issues/277) ).

### Узнать больше

*   [Уменьшите XSS с помощью строгой политики безопасности контента (CSP)](https://web.dev/articles/strict-csp?hl=ru)
*   [Памятка по политике безопасности контента](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html)

Доверенные типы
---------------

[XSS на основе DOM](https://portswigger.net/web-security/cross-site-scripting/dom-based) — это атака, при которой вредоносные данные передаются в приемник, поддерживающий динамическое выполнение кода, например `eval()` или `.innerHTML` .

Доверенные типы предоставляют инструменты для написания, проверки безопасности и поддержки приложений без DOM XSS. Их можно включить через [CSP](#csp) и сделать код JavaScript безопасным по умолчанию, ограничив опасные веб-API приемом только специального объекта — доверенного типа.

Чтобы создать эти объекты, вы можете определить политики безопасности, в которых вы можете гарантировать, что правила безопасности (такие как экранирование или очистка) последовательно применяются до записи данных в DOM. Эти политики являются единственными местами в коде, которые потенциально могут ввести DOM XSS.

Пример использования

    Content-Security-Policy: require-trusted-types-for 'script'

    // Feature detectionif (window.trustedTypes && trustedTypes.createPolicy) {  // Name and create a policy  const policy = trustedTypes.createPolicy('escapePolicy', {    createHTML: str => {      return str.replace(/\</g, '&lt;').replace(/>/g, '&gt;');    }  });}

    // Assignment of raw strings is blocked by Trusted Types.el.innerHTML = &#39;some string&#39;; // This throws an exception.// Assignment of Trusted Types is accepted safely.const escaped = policy.createHTML(&#39;&lt;img src=x onerror=alert(1)&gt;&#39;);el.innerHTML = escaped;  // &#39;&amp;lt;img src=x onerror=alert(1)&amp;gt;&#39;

Как использовать доверенные типы

### Рекомендуемое использование

1.  Принудительно использовать доверенные типы для опасных приемников DOM CSP и заголовка доверенных типов:
    
    Content\-Security\-Policy: require\-trusted\-types\-for 'script'  
    
    В настоящее время `'script'` является единственным приемлемым значением для директивы `require-trusted-types-for` .
    
    Конечно, вы можете комбинировать доверенные типы с другими директивами CSP:



